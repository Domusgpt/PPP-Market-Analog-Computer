<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase-Lock Stereoscopic Engine • PPP</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <script>
        // Configure PPP for Phase-Lock mode
        window.PPP_CONFIG = {
            exposeApi: true,
            autoStream: false,
            sonicGeometry: {
                autoEnable: true,
                mode: 'analysis'
            }
        };
    </script>
    <style>
        /* ══════════════════════════════════════════════════════════════════════
           WIDGEON BLOOD RUBY / SILICON WAFER DARK THEME
           ══════════════════════════════════════════════════════════════════════ */
        :root {
            --ruby-blood: #8b0a1a;
            --ruby-glow: #dc143c;
            --ruby-bright: #ff2d55;
            --silicon-deep: #0a0a0f;
            --silicon-dark: #12121a;
            --silicon-mid: #1a1a24;
            --silicon-light: #252532;
            --holo-cyan: #00f5ff;
            --holo-magenta: #ff00ff;
            --holo-gold: #ffd700;
            --text-primary: #f0f0f5;
            --text-secondary: rgba(240, 240, 245, 0.7);
            --glass-bg: rgba(18, 18, 26, 0.85);
            --glass-border: rgba(139, 10, 26, 0.4);
            color-scheme: dark;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            font-family: 'JetBrains Mono', monospace;
            background: var(--silicon-deep);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background:
                radial-gradient(ellipse 80% 50% at 20% 20%, rgba(139, 10, 26, 0.3), transparent 50%),
                radial-gradient(ellipse 60% 40% at 80% 80%, rgba(220, 20, 60, 0.15), transparent 50%),
                linear-gradient(180deg, var(--silicon-deep) 0%, #0d0d14 50%, var(--silicon-dark) 100%);
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(139, 10, 26, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(139, 10, 26, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridPulse 4s ease-in-out infinite;
            z-index: -1;
            pointer-events: none;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* ══════════════════════════════════════════════════════════════════════
           HOLOGRAPHIC TEXT EFFECTS
           ══════════════════════════════════════════════════════════════════════ */
        .holo-text {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(90deg, var(--holo-cyan) 0%, var(--holo-magenta) 25%, var(--holo-gold) 50%, var(--holo-cyan) 75%, var(--holo-magenta) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: holoShift 3s linear infinite;
        }

        @keyframes holoShift {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .holo-text-ruby {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(90deg, var(--ruby-glow) 0%, var(--ruby-bright) 25%, #ff6b8a 50%, var(--ruby-glow) 75%, var(--ruby-blood) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: holoShift 2.5s linear infinite;
        }

        /* ══════════════════════════════════════════════════════════════════════
           MAIN LAYOUT - PPP Hypercube Canvas + Control Panels
           ══════════════════════════════════════════════════════════════════════ */

        /* PPP Hypercube Canvas - Full screen background */
        #visualizerCanvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            background: radial-gradient(circle at center, rgba(139, 10, 26, 0.15), rgba(10, 10, 15, 0.95));
        }

        #spinorOverlay {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            pointer-events: none;
            mix-blend-mode: screen;
            z-index: 5;
        }

        /* Control panels overlay */
        .ui-layer {
            position: fixed;
            inset: 0;
            z-index: 10;
            display: grid;
            grid-template-columns: 340px 1fr 320px;
            grid-template-rows: auto 1fr auto;
            gap: 1rem;
            padding: 1rem;
            pointer-events: none;
        }

        .ui-layer > * {
            pointer-events: auto;
        }

        /* Header spans full width */
        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 1rem;
            backdrop-filter: blur(20px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--ruby-blood), var(--ruby-glow));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: iconPulse 2s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(220, 20, 60, 0.4);
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(220, 20, 60, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 50px rgba(220, 20, 60, 0.7); }
        }

        .logo h1 {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        .status-indicators {
            display: flex;
            gap: 1.5rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--ruby-glow);
            box-shadow: 0 0 10px var(--ruby-glow);
            animation: statusBlink 1s ease-in-out infinite;
        }

        .status-dot.active {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Left sidebar - PPP Controls */
        .left-panel {
            grid-column: 1;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
        }

        /* Right sidebar - Phase-Lock Metrics */
        .right-panel {
            grid-column: 3;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
        }

        /* Cards */
        .card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 1rem;
            padding: 1.25rem;
            backdrop-filter: blur(20px);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(139, 10, 26, 0.2);
        }

        .card-title {
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--ruby-glow);
        }

        /* Metrics grid */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .metric {
            background: rgba(139, 10, 26, 0.1);
            border: 1px solid rgba(139, 10, 26, 0.2);
            border-radius: 0.75rem;
            padding: 0.75rem;
            text-align: center;
        }

        .metric-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .metric-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        /* Rotation display */
        .rotation-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .rotation-plane {
            background: rgba(139, 10, 26, 0.15);
            border: 1px solid rgba(139, 10, 26, 0.25);
            border-radius: 0.5rem;
            padding: 0.5rem;
            text-align: center;
        }

        .plane-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .plane-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--holo-cyan);
        }

        /* Data feed */
        .feed-container {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--ruby-blood) transparent;
        }

        .feed-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(139, 10, 26, 0.1);
            font-size: 0.8rem;
        }

        .feed-item:last-child { border-bottom: none; }

        .feed-time { color: var(--text-secondary); font-size: 0.7rem; }

        .feed-price { font-family: 'Orbitron', sans-serif; font-weight: 600; }
        .feed-price.up { color: #00ff88; }
        .feed-price.down { color: var(--ruby-bright); }

        /* PPP Control styles */
        .control-group {
            margin-bottom: 0.75rem;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 0.35rem;
            color: var(--text-secondary);
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: var(--ruby-glow);
        }

        .btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--glass-border);
            background: rgba(139, 10, 26, 0.2);
            color: var(--ruby-glow);
            border-radius: 0.5rem;
            font-family: inherit;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: rgba(220, 20, 60, 0.3);
            border-color: var(--ruby-glow);
            box-shadow: 0 0 20px rgba(220, 20, 60, 0.3);
        }

        .btn.active, .btn:active {
            background: linear-gradient(135deg, var(--ruby-blood), var(--ruby-glow));
            color: white;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Footer */
        footer {
            grid-column: 1 / -1;
            grid-row: 3;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 1rem;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .footer-section {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .footer-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .footer-item span:first-child { color: var(--ruby-glow); }

        /* Scanlines */
        .scanlines {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 1000;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.03) 2px, rgba(0, 0, 0, 0.03) 4px);
            opacity: 0.5;
        }

        /* Connection panel */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 0.5rem;
            font-size: 0.7rem;
        }

        .connection-status.disconnected {
            background: rgba(139, 10, 26, 0.1);
            border-color: rgba(139, 10, 26, 0.3);
        }

        /* Hide on mobile */
        @media (max-width: 1200px) {
            .ui-layer { grid-template-columns: 1fr 280px; }
            .left-panel { display: none; }
        }

        @media (max-width: 768px) {
            .ui-layer { grid-template-columns: 1fr; }
            .right-panel { display: none; }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>

    <!-- PPP Hypercube Canvas -->
    <canvas id="visualizerCanvas"></canvas>
    <canvas id="spinorOverlay"></canvas>

    <!-- UI Layer -->
    <div class="ui-layer">
        <!-- Header -->
        <header>
            <div class="logo">
                <div class="logo-icon">◈</div>
                <div>
                    <h1 class="holo-text">PHASE-LOCK</h1>
                    <div style="font-size: 0.65rem; letter-spacing: 0.2em; color: var(--text-secondary);">PPP STEREOSCOPIC ENGINE</div>
                </div>
            </div>
            <div class="status-indicators">
                <div class="status-item">
                    <div class="status-dot active" id="engineStatus"></div>
                    <span>PPP Engine</span>
                </div>
                <div class="status-item">
                    <div class="status-dot active" id="syncStatus"></div>
                    <span>Phase-Lock</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="dataStatus"></div>
                    <span>Live Feed</span>
                </div>
            </div>
        </header>

        <!-- Left Panel: PPP Controls -->
        <aside class="left-panel">
            <!-- Data Source -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">Data Source</span>
                </div>
                <div class="btn-group" style="margin-bottom: 1rem;">
                    <button class="btn active" id="btnSimulation">Simulation</button>
                    <button class="btn" id="btnWebSocket">WebSocket</button>
                    <button class="btn" id="btnSerial">Serial</button>
                </div>
                <div id="connectionPanel" style="display: none;">
                    <div class="control-group">
                        <label>WebSocket URL</label>
                        <input type="text" id="wsUrl" value="ws://localhost:8080" style="width: 100%; padding: 0.5rem; background: rgba(139, 10, 26, 0.1); border: 1px solid var(--glass-border); border-radius: 0.5rem; color: var(--text-primary);">
                    </div>
                    <button class="btn" id="btnConnect" style="width: 100%; margin-top: 0.5rem;">Connect</button>
                </div>
                <div class="connection-status disconnected" id="connectionStatus">
                    <div class="status-dot"></div>
                    <span>Using Simulation Mode</span>
                </div>
            </div>

            <!-- PPP Mapping -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">PPP Mapping</span>
                </div>
                <div class="control-group">
                    <label>
                        <span>Smoothing</span>
                        <span id="smoothingValue">0.15</span>
                    </label>
                    <input type="range" id="smoothingSlider" min="0" max="1" step="0.01" value="0.15">
                </div>
                <div class="control-group">
                    <label>
                        <span>Latency Buffer</span>
                        <span id="latencyValue">50ms</span>
                    </label>
                    <input type="range" id="latencySlider" min="10" max="200" step="5" value="50">
                </div>
                <div class="control-group">
                    <label>
                        <span>Data Channels</span>
                        <span id="channelValue">16</span>
                    </label>
                    <input type="range" id="channelSlider" min="4" max="64" step="4" value="16">
                </div>
            </div>

            <!-- Spinor Telemetry -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">Spinor Telemetry</span>
                    <span style="font-size: 0.65rem; color: var(--holo-cyan);" id="spinorMode">Analysis</span>
                </div>
                <div id="spinorMetrics" style="font-size: 0.7rem; color: var(--text-secondary);">
                    <div>Hopf Fiber: <span id="hopfFiber">0.00</span></div>
                    <div>Parity: <span id="parityMetric">0.00</span></div>
                    <div>Resonance: <span id="resonanceMetric">0.00</span></div>
                </div>
            </div>
        </aside>

        <!-- Right Panel: Phase-Lock Metrics -->
        <aside class="right-panel">
            <!-- Phase-Lock Metrics -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">Phase-Lock Metrics</span>
                    <span style="font-size: 0.7rem; color: var(--holo-cyan);" id="fpsCounter">60 FPS</span>
                </div>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-value holo-text" id="metricLatency">50</div>
                        <div class="metric-label">Latency (ms)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value holo-text" id="metricBuffer">0</div>
                        <div class="metric-label">Buffer Size</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value holo-text-ruby" id="metricInterp">0%</div>
                        <div class="metric-label">Interpolation</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value holo-text-ruby" id="metricSync">0</div>
                        <div class="metric-label">Sync Errors</div>
                    </div>
                </div>
            </div>

            <!-- 4D Rotation State -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">4D Rotation Planes</span>
                </div>
                <div class="rotation-display">
                    <div class="rotation-plane">
                        <div class="plane-label">XY</div>
                        <div class="plane-value" id="rotXY">0.00°</div>
                    </div>
                    <div class="rotation-plane">
                        <div class="plane-label">XZ</div>
                        <div class="plane-value" id="rotXZ">0.00°</div>
                    </div>
                    <div class="rotation-plane">
                        <div class="plane-label">XW</div>
                        <div class="plane-value" id="rotXW">0.00°</div>
                    </div>
                    <div class="rotation-plane">
                        <div class="plane-label">YZ</div>
                        <div class="plane-value" id="rotYZ">0.00°</div>
                    </div>
                    <div class="rotation-plane">
                        <div class="plane-label">YW</div>
                        <div class="plane-value" id="rotYW">0.00°</div>
                    </div>
                    <div class="rotation-plane">
                        <div class="plane-label">ZW</div>
                        <div class="plane-value" id="rotZW">0.00°</div>
                    </div>
                </div>
            </div>

            <!-- Market Data Feed -->
            <div class="card" style="flex: 1;">
                <div class="card-header">
                    <span class="card-title">Market Data Feed</span>
                    <span style="font-size: 0.65rem; color: var(--text-secondary);" id="tickCount">0 ticks</span>
                </div>
                <div class="feed-container" id="dataFeed">
                    <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                        Waiting for data...
                    </div>
                </div>
            </div>
        </aside>

        <!-- Footer -->
        <footer>
            <div class="footer-section">
                <div class="footer-item">
                    <span>Engine:</span>
                    <span>PPP + Phase-Lock v1.0</span>
                </div>
                <div class="footer-item">
                    <span>Mode:</span>
                    <span id="footerMode">Simulation</span>
                </div>
            </div>
            <div class="footer-section">
                <div class="footer-item">
                    <span>Buffer:</span>
                    <span id="footerBuffer">50ms</span>
                </div>
                <div class="footer-item">
                    <span>Frames:</span>
                    <span id="footerFrames">0</span>
                </div>
            </div>
        </footer>
    </div>

    <!-- PPP Core + Phase-Lock Integration -->
    <script type="module">
        // Import PPP Core Components
        import { HypercubeRenderer } from './scripts/HypercubeRenderer.js';
        import { DataMapper } from './scripts/DataMapper.js';
        import { defaultMapping } from './scripts/defaultMapping.js';
        import { SonicGeometryEngine } from './scripts/SonicGeometryEngine.js';
        import { WebSocketQuaternionAdapter, SerialQuaternionAdapter } from './scripts/LiveQuaternionAdapters.js';
        import { DATA_CHANNEL_COUNT } from './scripts/constants.js';

        // Import Phase-Lock Engine
        import { StereoscopicFeed, TimeBinder, Quaternion, slerp } from './scripts/PhaseLockEngine.js';

        // ═══════════════════════════════════════════════════════════════════════
        // PPP HYPERCUBE RENDERER SETUP
        // ═══════════════════════════════════════════════════════════════════════
        const canvas = document.getElementById('visualizerCanvas');
        const spinorCanvas = document.getElementById('spinorOverlay');

        const renderer = new HypercubeRenderer(canvas, {
            pixelRatio: Math.min(window.devicePixelRatio, 2),
            antialias: true
        });

        const mapper = new DataMapper(defaultMapping);

        // Initialize SonicGeometryEngine for spinor telemetry
        let sonicEngine = null;
        try {
            sonicEngine = new SonicGeometryEngine({
                mode: 'analysis',
                spinorOverlayCanvas: spinorCanvas
            });
            console.log('%c⬡ SonicGeometryEngine initialized', 'color: #00f5ff;');
        } catch (e) {
            console.warn('SonicGeometryEngine not available:', e.message);
        }

        // ═══════════════════════════════════════════════════════════════════════
        // PHASE-LOCK STEREOSCOPIC FEED
        // ═══════════════════════════════════════════════════════════════════════
        const feed = new StereoscopicFeed({
            smoothing: true,
            chartHistorySize: 500,
            timeBinder: {
                latencyBuffer: 50,
                bufferSize: 1000
            }
        });

        // ═══════════════════════════════════════════════════════════════════════
        // LIVE DATA ADAPTERS
        // ═══════════════════════════════════════════════════════════════════════
        let wsAdapter = null;
        let serialAdapter = null;
        let dataSource = 'simulation';

        // ═══════════════════════════════════════════════════════════════════════
        // MARKET SIMULATION
        // ═══════════════════════════════════════════════════════════════════════
        let price = 100;
        let tickHistory = [];
        const maxHistory = 50;
        let channelCount = 16;
        let latencyBuffer = 50;

        function simulateMarketTick() {
            if (dataSource !== 'simulation') return;

            // Random walk with momentum
            const momentum = (Math.random() - 0.48) * 0.5;
            price = Math.max(50, Math.min(150, price + momentum));

            const tick = {
                price: price,
                volume: Math.random() * 10000,
                bid: price - Math.random() * 0.1,
                ask: price + Math.random() * 0.1
            };

            feed.ingest(tick);

            // Update history
            tickHistory.push({
                time: new Date(),
                price: price,
                direction: momentum >= 0 ? 'up' : 'down'
            });
            if (tickHistory.length > maxHistory) {
                tickHistory.shift();
            }

            updateDataFeed();
        }

        function updateDataFeed() {
            const container = document.getElementById('dataFeed');
            const recent = tickHistory.slice(-10).reverse();

            container.innerHTML = recent.map(tick => `
                <div class="feed-item">
                    <span class="feed-time">${tick.time.toLocaleTimeString()}</span>
                    <span class="feed-price ${tick.direction}">$${tick.price.toFixed(2)}</span>
                </div>
            `).join('');

            document.getElementById('tickCount').textContent = `${tickHistory.length} ticks`;
            document.getElementById('dataStatus').classList.add('active');
        }

        // ═══════════════════════════════════════════════════════════════════════
        // PHASE-LOCK → PPP RENDERER BRIDGE
        // ═══════════════════════════════════════════════════════════════════════
        function phaseLockToDataArray(frame, channelCount) {
            // Convert phase-locked frame to PPP data channels
            const rotation = frame.rightEye?.smoothedRotation || {
                rotXY: 0, rotXZ: 0, rotXW: 0, rotYZ: 0, rotYW: 0, rotZW: 0
            };

            const priceData = frame.leftEye?.priceHistory || [];
            const normalizedPrice = priceData.length > 0
                ? (priceData[priceData.length - 1] - 50) / 100
                : 0.5;

            // Build data array for PPP
            const data = new Array(channelCount).fill(0);
            const time = performance.now() * 0.001;

            // Price-driven channels (0-3)
            data[0] = normalizedPrice;
            data[1] = Math.sin(normalizedPrice * Math.PI * 2) * 0.5 + 0.5;
            data[2] = Math.cos(normalizedPrice * Math.PI * 2) * 0.5 + 0.5;
            data[3] = (normalizedPrice + Math.sin(time * 2)) * 0.5;

            // Rotation-driven channels (4-9) - normalized to 0-1
            const norm = (v) => ((v % (Math.PI * 2)) / (Math.PI * 2) + 1) % 1;
            data[4] = norm(rotation.rotXY);
            data[5] = norm(rotation.rotXZ);
            data[6] = norm(rotation.rotXW);
            data[7] = norm(rotation.rotYZ);
            data[8] = norm(rotation.rotYW);
            data[9] = norm(rotation.rotZW);

            // Synthetic harmonic channels (10+)
            for (let i = 10; i < channelCount; i++) {
                const harmonic = Math.sin(time * (0.5 + i * 0.1) + normalizedPrice * Math.PI);
                data[i] = harmonic * 0.5 + 0.5;
            }

            return data;
        }

        // ═══════════════════════════════════════════════════════════════════════
        // RENDER LOOP
        // ═══════════════════════════════════════════════════════════════════════
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        let totalFrames = 0;

        function render(timestamp) {
            frameCount++;
            totalFrames++;

            // FPS calculation
            if (timestamp - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (timestamp - lastTime));
                frameCount = 0;
                lastTime = timestamp;
                document.getElementById('fpsCounter').textContent = `${fps} FPS`;
            }

            // Get phase-locked frame
            const frame = feed.frame(timestamp);
            const rotation = frame.rightEye?.smoothedRotation || {
                rotXY: 0, rotXZ: 0, rotXW: 0, rotYZ: 0, rotYW: 0, rotZW: 0
            };

            // Convert to PPP data array
            const dataArray = phaseLockToDataArray(frame, channelCount);

            // Apply to PPP renderer via DataMapper
            const uniforms = mapper.mapToUniforms(dataArray);

            // Override rotations with phase-locked values
            uniforms.u_rotXY = rotation.rotXY;
            uniforms.u_rotXZ = rotation.rotXZ;
            uniforms.u_rotXW = rotation.rotXW;
            uniforms.u_rotYZ = rotation.rotYZ;
            uniforms.u_rotYW = rotation.rotYW;
            uniforms.u_rotZW = rotation.rotZW;
            uniforms.u_time = timestamp * 0.001;

            // Render PPP Hypercube
            renderer.setUniforms(uniforms);
            renderer.render();

            // Feed to SonicGeometryEngine if available
            if (sonicEngine) {
                try {
                    sonicEngine.processFrame({
                        rotation: [rotation.rotXY, rotation.rotXZ, rotation.rotXW, rotation.rotYZ, rotation.rotYW, rotation.rotZW],
                        dataChannels: dataArray,
                        timestamp: timestamp
                    });

                    // Update spinor metrics
                    const metrics = sonicEngine.getMetrics?.() || {};
                    document.getElementById('hopfFiber').textContent = (metrics.hopfFiber || 0).toFixed(3);
                    document.getElementById('parityMetric').textContent = (metrics.parity || 0).toFixed(3);
                    document.getElementById('resonanceMetric').textContent = (metrics.resonance || 0).toFixed(3);
                } catch (e) {
                    // Silently handle if sonic engine methods aren't available
                }
            }

            // Update rotation display
            const toDeg = r => ((r * 180 / Math.PI) % 360).toFixed(1) + '°';
            document.getElementById('rotXY').textContent = toDeg(rotation.rotXY);
            document.getElementById('rotXZ').textContent = toDeg(rotation.rotXZ);
            document.getElementById('rotXW').textContent = toDeg(rotation.rotXW);
            document.getElementById('rotYZ').textContent = toDeg(rotation.rotYZ);
            document.getElementById('rotYW').textContent = toDeg(rotation.rotYW);
            document.getElementById('rotZW').textContent = toDeg(rotation.rotZW);

            // Update Phase-Lock metrics
            const metrics = feed.getMetrics();
            document.getElementById('metricLatency').textContent = latencyBuffer;
            document.getElementById('metricBuffer').textContent = metrics.timeBinderMetrics?.bufferSize || 0;
            document.getElementById('metricInterp').textContent =
                ((metrics.timeBinderMetrics?.interpolationRate || 0) * 100).toFixed(0) + '%';
            document.getElementById('metricSync').textContent = metrics.timeBinderMetrics?.syncErrors || 0;

            // Footer updates
            document.getElementById('footerFrames').textContent = totalFrames;
            document.getElementById('footerBuffer').textContent = latencyBuffer + 'ms';

            requestAnimationFrame(render);
        }

        // ═══════════════════════════════════════════════════════════════════════
        // UI EVENT HANDLERS
        // ═══════════════════════════════════════════════════════════════════════

        // Data source buttons
        document.getElementById('btnSimulation').addEventListener('click', () => {
            dataSource = 'simulation';
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('connectionStatus').className = 'connection-status disconnected';
            document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div><span>Using Simulation Mode</span>';
            document.getElementById('footerMode').textContent = 'Simulation';
            document.querySelectorAll('.btn-group .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btnSimulation').classList.add('active');
        });

        document.getElementById('btnWebSocket').addEventListener('click', () => {
            document.getElementById('connectionPanel').style.display = 'block';
            document.querySelectorAll('.btn-group .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btnWebSocket').classList.add('active');
        });

        document.getElementById('btnSerial').addEventListener('click', () => {
            dataSource = 'serial';
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('footerMode').textContent = 'Serial';
            document.querySelectorAll('.btn-group .btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btnSerial').classList.add('active');

            // Try to connect to serial
            if (serialAdapter) serialAdapter.disconnect();
            serialAdapter = new SerialQuaternionAdapter({
                onFrame: (frame) => {
                    feed.ingest({
                        price: frame.channels?.[0] || 100,
                        volume: frame.channels?.[1] || 0,
                        rotation: frame.rotation
                    });
                }
            });
            serialAdapter.connect().then(() => {
                document.getElementById('connectionStatus').className = 'connection-status';
                document.getElementById('connectionStatus').innerHTML = '<div class="status-dot active"></div><span>Serial Connected</span>';
            }).catch(err => {
                document.getElementById('connectionStatus').className = 'connection-status disconnected';
                document.getElementById('connectionStatus').innerHTML = `<div class="status-dot"></div><span>Serial Error: ${err.message}</span>`;
            });
        });

        document.getElementById('btnConnect').addEventListener('click', () => {
            const url = document.getElementById('wsUrl').value;
            dataSource = 'websocket';
            document.getElementById('footerMode').textContent = 'WebSocket';

            if (wsAdapter) wsAdapter.disconnect();
            wsAdapter = new WebSocketQuaternionAdapter(url, {
                onFrame: (frame) => {
                    feed.ingest({
                        price: frame.channels?.[0] || 100,
                        volume: frame.channels?.[1] || 0,
                        rotation: frame.rotation
                    });
                    updateDataFeed();
                },
                onStatus: (status) => {
                    if (status === 'connected') {
                        document.getElementById('connectionStatus').className = 'connection-status';
                        document.getElementById('connectionStatus').innerHTML = '<div class="status-dot active"></div><span>WebSocket Connected</span>';
                    } else {
                        document.getElementById('connectionStatus').className = 'connection-status disconnected';
                        document.getElementById('connectionStatus').innerHTML = `<div class="status-dot"></div><span>${status}</span>`;
                    }
                }
            });
            wsAdapter.connect();
        });

        // Sliders
        document.getElementById('smoothingSlider').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            document.getElementById('smoothingValue').textContent = val.toFixed(2);
            mapper.setSmoothingFactor(val);
        });

        document.getElementById('latencySlider').addEventListener('input', (e) => {
            latencyBuffer = parseInt(e.target.value);
            document.getElementById('latencyValue').textContent = latencyBuffer + 'ms';
            feed.timeBinder?.setLatencyBuffer?.(latencyBuffer);
        });

        document.getElementById('channelSlider').addEventListener('input', (e) => {
            channelCount = parseInt(e.target.value);
            document.getElementById('channelValue').textContent = channelCount;
        });

        // ═══════════════════════════════════════════════════════════════════════
        // EXPOSE PPP API
        // ═══════════════════════════════════════════════════════════════════════
        window.PPP = {
            renderer,
            mapper,
            sonicGeometry: sonicEngine,
            phaseLock: feed,
            getMetrics: () => ({
                fps,
                totalFrames,
                phaseLock: feed.getMetrics(),
                renderer: renderer.getUniformState()
            })
        };

        // ═══════════════════════════════════════════════════════════════════════
        // START
        // ═══════════════════════════════════════════════════════════════════════
        setInterval(simulateMarketTick, 100);
        requestAnimationFrame(render);

        console.log('%c⬡ PPP Phase-Lock Engine Initialized', 'color: #dc143c; font-size: 14px; font-weight: bold;');
        console.log('%c  Access via window.PPP', 'color: #00f5ff;');
    </script>
</body>
</html>
